package gobinsec

import (
	"fmt"
)

const URL = "https://services.nvd.nist.gov/rest/json/cves/1.0/?keyword="

// Vulnerability for a vulnerability
type Vulnerability struct {
	ID         string         // CVE ID
	References []string       // Reference URL
	Matchs     []VersionMatch // version matching
	Exposed    bool           // tells if this vulnerability is exposed
}

// NewVulnerability builds a vulnerability from NVD call result
func NewVulnerability(item Item) (*Vulnerability, error) {
	vulnerability := Vulnerability{
		ID: item.CVE.Metadata.ID,
	}
	for _, reference := range item.CVE.References.ReferenceData {
		vulnerability.References = append(vulnerability.References, reference.URL)
	}
	for _, node := range item.Configurations.Nodes {
		for _, match := range node.Match {
			if match.Vulnerable && (match.VersionEndExcluding != "" ||
				match.VersionEndIncluding != "") {
				vm, err := NewVersionMatch(match)
				if err != nil {
					return nil, err
				}
				vulnerability.Matchs = append(vulnerability.Matchs, *vm)
			}
		}
	}
	return &vulnerability, nil
}

func (v *Vulnerability) IsExposed(version Version) (bool, error) {
	for _, match := range v.Matchs {
		m, err := match.Match(version)
		if err != nil {
			return false, err
		}
		if m {
			v.Exposed = true
			return true, nil
		}
	}
	return false, nil
}

// VersionMatch are version constraints for vulnerability
type VersionMatch struct {
	VersionEndExcluding Version
	VersionEndIncluding Version
}

// NewVersionMatch return a version match
func NewVersionMatch(m Match) (*VersionMatch, error) {
	if m.VersionEndExcluding != "" {
		v, err := NewVersion(m.VersionEndExcluding)
		if err != nil {
			return nil, err
		}
		vm := VersionMatch{VersionEndExcluding: v}
		return &vm, nil
	}
	if m.VersionEndIncluding != "" {
		v, err := NewVersion(m.VersionEndIncluding)
		if err != nil {
			return nil, err
		}
		vm := VersionMatch{VersionEndIncluding: v}
		return &vm, nil
	}
	return nil, fmt.Errorf("including and excluding both empty")
}

// Match tells if given version matches (so that it is affected by vulnerability)
func (m *VersionMatch) Match(v Version) (bool, error) {
	if m.VersionEndExcluding != nil {
		r, err := m.VersionEndExcluding.Compare(v)
		if err != nil {
			return false, err
		}
		return r > 0, nil
	}
	if m.VersionEndIncluding != nil {
		r, err := m.VersionEndIncluding.Compare(v)
		if err != nil {
			return false, err
		}
		return r >= 0, nil
	}
	return false, fmt.Errorf("bad version match")
}
