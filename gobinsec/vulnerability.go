package gobinsec

// Vulnerability for a vulnerability
type Vulnerability struct {
	ID         string               // CVE ID
	References []string             // Reference URL
	Matchs     []VulnerabilityMatch // version matching
	Exposed    bool                 // tells if this vulnerability is exposed
	Ignored    bool                 // tells id this vulnerability is ignored
}

// NewVulnerability builds a vulnerability from NVD call result
func NewVulnerability(item Item) (*Vulnerability, error) {
	vulnerability := Vulnerability{
		ID: item.CVE.Metadata.ID,
	}
	for _, reference := range item.CVE.References.ReferenceData {
		vulnerability.References = append(vulnerability.References, reference.URL)
	}
	for _, node := range item.Configurations.Nodes {
		for _, match := range node.Match {
			if match.Vulnerable && (match.VersionStartExcluding != "" ||
				match.VersionStartIncluding != "" ||
				match.VersionEndExcluding != "" ||
				match.VersionEndIncluding != "") {
				vm, err := NewVersionMatch(match)
				if err != nil {
					return nil, err
				}
				vulnerability.Matchs = append(vulnerability.Matchs, *vm)
			}
		}
	}
	vulnerability.Ignored = config.IgnoreVulnerability(vulnerability.ID)
	return &vulnerability, nil
}

func (v *Vulnerability) IsExposed(version Version) (bool, error) {
	for _, match := range v.Matchs {
		m, err := match.Match(version)
		if err != nil {
			return false, err
		}
		if m {
			v.Exposed = true
			return true, nil
		}
	}
	return false, nil
}

// VulnerabilityMatch are version constraints for vulnerability
type VulnerabilityMatch struct {
	VersionStartExcluding Version
	VersionStartIncluding Version
	VersionEndExcluding   Version
	VersionEndIncluding   Version
}

// NewVersionMatch return a version match
func NewVersionMatch(m Match) (*VulnerabilityMatch, error) {
	var vm VulnerabilityMatch
	if m.VersionStartExcluding != "" {
		v, err := NewVersion(m.VersionStartExcluding)
		if err != nil {
			return nil, err
		}
		vm.VersionStartExcluding = v
	}
	if m.VersionStartIncluding != "" {
		v, err := NewVersion(m.VersionStartIncluding)
		if err != nil {
			return nil, err
		}
		vm.VersionStartIncluding = v
	}
	if m.VersionEndExcluding != "" {
		v, err := NewVersion(m.VersionEndExcluding)
		if err != nil {
			return nil, err
		}
		vm.VersionEndExcluding = v
	}
	if m.VersionEndIncluding != "" {
		v, err := NewVersion(m.VersionEndIncluding)
		if err != nil {
			return nil, err
		}
		vm.VersionEndIncluding = v
	}
	return &vm, nil
}

// Match tells if given version matches (so that it is affected by vulnerability)
func (m *VulnerabilityMatch) Match(v Version) (bool, error) {
	if m.VersionStartExcluding != nil {
		r, err := m.VersionStartExcluding.Compare(v)
		if err != nil {
			return false, err
		}
		if r >= 0 {
			return false, nil
		}
	}
	if m.VersionStartIncluding != nil {
		r, err := m.VersionStartIncluding.Compare(v)
		if err != nil {
			return false, err
		}
		if r > 0 {
			return false, nil
		}
	}
	if m.VersionEndExcluding != nil {
		r, err := m.VersionEndExcluding.Compare(v)
		if err != nil {
			return false, err
		}
		if r <= 0 {
			return false, nil
		}
	}
	if m.VersionEndIncluding != nil {
		r, err := m.VersionEndIncluding.Compare(v)
		if err != nil {
			return false, err
		}
		if r < 0 {
			return false, nil
		}
	}
	return true, nil
}
